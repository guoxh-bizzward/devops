# MySQL索引优化

### like语句的前导模糊查询不能使用索引

``` sql
-- 不能使用索引
select * from test where title like '%xx';
-- 非前导模糊查询,可以使用索引;
select * from test where title like 'xx%';
```

### 负向条件查询不能使用索引



### 不能使用索引中范围条件右边的列(范围列可以用到索引),范围列之后列的索引全失效



### 强制类型转换会全表扫描



### 利用覆盖索引来进行查询操作,避免回表,减少select *的使用



### is null,is not null 无法使用索引



### 使用短索引(前缀索引)



### 如果明确知道只有一条结果返回,limit 1能够提高效率



### 单表索引建议控制在5个之内



### 业务上具有唯一特性的字段,即使是使用多个字段的组合,也必须建成唯一索引



### union,in,all都能命中索引,建议使用in



### 联合索引最左前缀原则



### 不要在索引列上做任何操作(计算,函数),否则会导致索引失效而转向全表扫描



### 更新十分频繁,数据分区不高的列不宜建立索引



### 索引不会包含含有null值的列



### 如果有 order by,group by的场景,请注意利用索引的有序性



### 利用延迟关联或者子查询优化超多页场景



### 超过三个表最好不用join



### SQL性能优化 explain 中的type.至少要达到range级别,要求是ref级别,如果可以是consts最好



### 创建索引时避免以下错误观念

```
1.索引越多约好,认为需要一个查询就建一个索引
2.宁缺毋滥,认为索引会消耗空间,严重拖慢更新和新增速度
3.抵制唯一索引,认为业务的唯一性一律需要在应用层通过"先查后插"方式解决.
4.过早优化,在不了解系统的情况下就开始优化.
```




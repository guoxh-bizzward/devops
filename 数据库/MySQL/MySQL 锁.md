# MySQL 锁

## 表锁



## 行锁



## 共享锁(S锁,读锁)

使用说明:若事务A对数据对象1加S锁,则其他事务A可以读取数据对象1但不能修改,其他事务只能再对数据 对象1加S锁,不能加X锁.指导事务A释放数据对象1上的S锁.这保证了其他事务可以读取数据对象1,但是事务A释放数据对象1上的S锁之前不能对数据对象1做任何修改.

用法

```
select ... lock in share mode;
#共享锁就是多个事务对于同一数据可以共享一把锁,都能访问数据,但是只能读不能修改;
```

## 排它锁(X锁,写锁)

使用说明:若事务A对数据对象1加X锁,事务A可以读取数据对象1也可以修改数据对象1,其他事务不能再对数据对象1加任何锁,直到事务A释放数据对象1上的锁.这保证了其他事务在事务A释放数据对象1上的锁之前不能再读取和修改数据对象1

用法

```
select ... for update
#排它锁就是不能与其他锁共存,如一个事务获取了一个数据行的排它锁,其他事务就不能再获取改行的排它锁.
```

## 意向共享锁(IS)和意向排他锁(IX)

意向共享锁:事务想要获取表中某些记录的共享锁,需要在表上先加意向共享锁;

意向排它锁:事务想要获取表中某些记录的互斥锁,需要在表上先加意向互斥锁.

意向共享锁和意向排它锁统称意向锁.意向锁的出现是为了支持innodb支持多粒度锁.

意向锁是表锁.

意向锁的作用

当一个事务自爱需要获取资源的锁定时,如果该资源已经被排它锁占用,则数据库会自动给该事务申请一个该表的意向锁.如果自己需要一个共享锁定,就申请一个意向共享锁.如果需要的是某行的排它锁,则申请一个意向排它锁.

## 乐观锁

乐观锁不是数据库自带的,需要我们自己实现.

读用乐观锁,写用悲观锁.

## 悲观锁

实现悲观锁,首先需要关闭MySQL的 autocommit; `set autocommit=0;`



```
下面三种锁都是innodb的行锁,行锁是基于索引实现的,一旦教唆操作没有操作在索引上,就会退化成表锁.
```

## 间隙锁

间隙锁,作用于非唯一索引上,主要目的是为了防止其他事务在间隔中插入数据,以导致"不可重复读".

如果把事务的隔离级别调整为  读提交(read committed RC),间隙锁自动失效.

## 记录锁

记录锁,封锁索引记录,作用域唯一索引上.

## 临键锁

临键锁,作用于非唯一索引上,是记录锁与间隙锁的组合.

## 死锁


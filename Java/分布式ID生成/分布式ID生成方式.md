# 分布式ID

分布式ID需要满足以下条件

* 全局唯一
* 高性能
* 高可用
* 好接入
* 趋势递增 最好趋势递增,看具体场景,不严格要求

## UUID

形式 8-4-4-12 共计36个字符

优点: 生成足够简单,本地生成无网络消耗,具有唯一性

缺点:无序的字符串,不具备趋势递增特性,没有具体业务含义,MySQL主键不推荐使用;

## 基于数据库自增

优点: 实现简单,ID单调递增,数值类型查询速度快

缺点:DB单点存在宕机风险,无法抗住高并发场景

## 基于数据库集群模式

集群不同机器设置不同的起始点和步长.

优点:解决DB单点问题

缺点:不利于后期扩容,实际上单个数据库自身的压力还是很大

## 基于数据库的号段模式

号段模式是当下分布式ID生成器的主流实现方式之一.号段模式可以理解为`从数据库批量的获取自增ID`,每次从数据库取出一个号段范围,比如(1,1000],具体的业务将本号段生成1-1000的自增id并加载到内存.

```
CREATE TABLE id_generator ( 
`id` int(10) NOT NULL, 
`max_id` bigint(20) NOT NULL COMMENT '当前最大id', 
`step` int(20) NOT NULL COMMENT '号段的步长',  
`biz_type`    int(20) NOT NULL COMMENT '业务类型',  
`version` int(20) NOT NULL COMMENT '版本号',  
PRIMARY KEY (`id`)
)
```

由于多业务端可能同时操作,所以采用版本号version乐观锁方式更新,这种分布式ID生成方式不强依赖数据库,不会频繁访问数据库,对数据库压力小很多.但是如果遇到双十一或者秒杀类似的活动还是会对数据库有比较高的访问.

## 基于 Redis模式

redis是单线程,可以利用redis的incr命令实现id的原子性自增.

用redis实现需要注意一点,就是redis的持久化问题.redis有两种持久化方式RDB和AOF

## 基于雪花算法

雪花算法核心思想:使用一个64bit的long型的数字作为全局唯一id

* 第一个部分是1bit:0,表示正数,无意义
* 第二个部分是41个bit,表示的是时间戳毫秒值,可以表示69年
* 第三个部分是5bit,表示是的机房id 最多代表32个机房
* 第四个部分是5bit,表示的是机器id,每个机房达标32台机器
* 第五个部分是12bit,表示的序号,某个机房的某台机器一毫秒可以生成的id序号,12bit最大可以代表4096个正整数

优点:

* 高性能高可用:生成时不依赖于数据库,完全在内存中生成
* 容量大:每秒可以生产数百万的自增id
* id自增:存入数据库,索引效率高

缺点:

* 依赖与系统时间的一致性,如果系统事件被回调或者改变,可能会造成id冲突或者重复

## 百度uid-generator

https://github.com/baidu/uid-generator



## 美团leaf

https://github.com/Meituan-Dianping/Leaf



## 滴滴 Tinyid

https://github.com/didi/tinyid




# JVM

## JVM 运行机制

jvm是运行Java字节码的虚拟机,包括

* 字节码指令集
* 程序寄存器
* 虚拟机栈
* 虚拟机堆
* 方法区
* 垃圾回收区

Java程序的具体运行过程

1. java源文件被编译器编译成字节码文件
2. JVM将字节码文件编译成相应操作系统的机器码
3. 机器码调用相应操作系统的本地方法库执行相应的方法

Java虚拟机包括

* 类加载器子系统(Class loader SubSystem) 将编译好的.class文件加载到JVM中
* 运行时数据区(Runtime Data Area) 存储在JVM运行过程中产生的数据,包括程序计数器,方法区,本地方法区,虚拟机栈和虚拟机堆
* 执行引擎 包括即时编译器和垃圾回收器,即时编译器用于将java字节码编译成具体的机器码,垃圾回收器用于回收再运行过程中不再使用的对象
* 本地接口库(Native Interface Libary).本地接口库通过调用本地方法库(Native Method Libary)与操作系统交互.

## 多线程

在JVM后台运行的线程主要有以下几个:

* 虚拟机线程(JVM Thread): 虚拟机线程在JVM到达安全点(SafePoint)时出现;
* 周期性任务线程:通过定时器调线程来实现周期性操作的执行
* GC线程:GC线程支持JVM中不同的垃圾回收活动
* 编译器线程:编译器线程在运行时将字节码动态编译成本地平台机器码,是JVM跨平台的具体体现
* 信号分发器线程:接收发送到JVM信号并调用JVM方法

## JVM的内存区域

JVM内存区域分为线程私有区域(程序计数器,虚拟机栈,本地方法区),线程共享区域(虚拟机堆,方法区)和直接内存

直接内存又叫做堆外内存,它不是JVM运行时数据区的一部分.但是在并发编程中被频繁使用.JDK的NIO模块提供的基于channel和buffer的I/O操作方式就是基于堆外内存实现的,NIO通过调用native函数直接在操作系统上分配堆外内存,然后使用DirectoryByteBuffer对象作为这块内存的引用对内存进行操作

```
Java进程可以通过堆外内存基数避免在Java堆和Native堆中来回复制数据带来的资源占用和性能消耗,因此堆外内存在高并发应用场景下被广泛应用(Netty,Flink,HBase,Hadoop都有使用堆外内存) 
```



## JVM 的运行时内存

JVM运行时内存也叫做JVM堆,从GC的角度分为 新生代,老年代和永久代.新生代默认占1/3空间,老年代默认占2/3空间,永久代只占用很少的堆空间.

新生代又分为 Eden区(8/10),ServivorFrom(1/10)和ServivorTo(1/10)空间

* Eden: Java新创建的对象会首先被存放到Eden区.如果新创建的对象属于大对象,直接分配到老年代.在Eden区内存空间不足的时候会触发MinortGC,对新生代进行一次垃圾回收.

```
大对象的定义根据具体的jvm版本,堆大小和垃圾回收策略有关,可以通过XX:PretenureSizeThreshold设置其大小.一般是2KB~128KB
```

* ServivorTo:保留上一次MinorGC时的幸存者
* ServivorFrom:将上一次MinorGC时的幸存者作为这一次MinorGC的被扫描者.

新生代的GC过程叫做Minor GC.采用复制算法实现.

* 把eden区和servivorFrom区中存活对象复制到servivorTo区.如果某对象的年龄到达老年代标准,则将其复制到老年代,同时把这些对象的年龄加1,如果servivorTo区内存不够,则也直接将其复制到老年代,如果对象属于大对象,也直接将其复制到老年代

```
对象晋升老年代的标准由 XX:MaxTenuringThreshold设置,默认是15
```

* 清空eden和servivorFrom区域的对象
* 将servivorTo区和servivorFrom区对换,原来的servivorTo区成为下一次GC时的ServivorFrom区

老年代主要存放有长生命周期的对象和大对象.老年代的GC过程叫做Major GC.MajorGC使用标记清除算法,该算法首先会扫描所有对象并标记存活对象,然后回收未被标记的对象,并释放内存空间.

```
在进行majorGC前,jvm会先进行一次Minor GC,如果MinorGC过后仍然出现老年代空间不足或者无法找到足够大的连续空间分配给新创建的大对象时,会触发Major GC进行垃圾回收.
Major会扫描所有老年代对象再回收,所以MajorGC的耗时比较长.同时MajorGC使用的标记清除算法容易产生内存碎片.在没有内存空间分配的时候,会报out of memory.
```

永久代指内存的永久保存区域,主要存放Class和meta(元数据)信息.Class在类加载时被放入永久代.GC不会在运行期间对永久代内存进行回收.所以永久代会随着Class的文件增加而增加,Class文件加载过多时会抛出Out of Memory.

```
在java8中,永久代被元数据区(元空间)取代.元数据区的作用和永久代类似,最大的区别是:
元数据区没有使用虚拟机的内存,而是直接使用操作系统的本地内存.因此,元空间的大小不受JVM内存限制,只和操作系统的内存有关.
在java8中,JVM将类的元数据放入本地内存(natvive memory)中,将常量池和类的静态变量放入java堆中.这样JVM能够加载多少元数据信息就不再由JVM的最大可用内存(MaxPermSize)空间决定,而是由操作系统的实际可用内存空间绝顶
```



## 垃圾回收与算法

### 如何确定垃圾

java采用引用计数器和可达性分析来确定对象是否可回收.

* 引用计数器方式容易产生循环依赖问题.
* 可达性分析 具体做法是首先定义一些GC Roots对象,然后以这些GC Roots对象作为起点向下搜索,如果在GC Roots和一个对象之间没有可达路径,则称该对象不可达.

```
不可达对象需要经过至少两次标记才能判定其是否可以被回收,如果在两次标记后该对象仍然是不可达的,则将被垃圾回收期回收.
```

### 常用垃圾回收算法

* 标记清除(Mark-Sweep)

分为标记和清除两个部分.在标记阶段标记所有需要回收的对象,在清除阶段清除可回收的对象并释放其所占的内存空间.

缺点:会引起内存碎片化问题,会引起大对象无法获得连续可用空间的问题

* 复制算法(Copying)

为了解决标记清除算法内存碎片化问题而设计的.

复制算法的内存清理效率高而易于实现,但是由于同一时刻只有一个内存区域可用,即可用的内存被压缩到原来的一半.因此存在大量的内存浪费.如果系统中有大量长时间存活对象时,在两个内存区域之间复制会影响系统效率.因此该算法只在对象"朝生夕死"状态下效率最高.

* 标记整理(Mark-Compact)

标记整理算法结合了标记清除算法和赋值算法的优点,其标记节点和标记清除算法节点相同,在标记完成后将存活对象移动到内存的另一端,然后清除该端对象并释放内存.

* 分代收集(Generational Collecting)

针对不同的对象类型,JVM采用了不同的垃圾回收算法,该算法被称为分代收集算法.

## Java中的4种引用类型



## 分代收集算法和分区收集算法



## 垃圾收集器



## Java 网络编程模型



## JVM 类加载机制


# JVM

## JVM 运行机制

jvm是运行Java字节码的虚拟机,包括

* 字节码指令集
* 程序寄存器
* 虚拟机栈
* 虚拟机堆
* 方法区
* 垃圾回收区

Java程序的具体运行过程

1. java源文件被编译器编译成字节码文件
2. JVM将字节码文件编译成相应操作系统的机器码
3. 机器码调用相应操作系统的本地方法库执行相应的方法

Java虚拟机包括

* 类加载器子系统(Class loader SubSystem) 将编译好的.class文件加载到JVM中
* 运行时数据区(Runtime Data Area) 存储在JVM运行过程中产生的数据,包括程序计数器,方法区,本地方法区,虚拟机栈和虚拟机堆
* 执行引擎 包括即时编译器和垃圾回收器,即时编译器用于将java字节码编译成具体的机器码,垃圾回收器用于回收再运行过程中不再使用的对象
* 本地接口库(Native Interface Libary).本地接口库通过调用本地方法库(Native Method Libary)与操作系统交互.

## 多线程

在JVM后台运行的线程主要有以下几个:

* 虚拟机线程(JVM Thread): 虚拟机线程在JVM到达安全点(SafePoint)时出现;
* 周期性任务线程:通过定时器调线程来实现周期性操作的执行
* GC线程:GC线程支持JVM中不同的垃圾回收活动
* 编译器线程:编译器线程在运行时将字节码动态编译成本地平台机器码,是JVM跨平台的具体体现
* 信号分发器线程:接收发送到JVM信号并调用JVM方法

## JVM的内存区域

JVM内存区域分为线程私有区域(程序计数器,虚拟机栈,本地方法区),线程共享区域(虚拟机堆,方法区)和直接内存

直接内存又叫做堆外内存,它不是JVM运行时数据区的一部分.但是在并发编程中被频繁使用.JDK的NIO模块提供的基于channel和buffer的I/O操作方式就是基于堆外内存实现的,NIO通过调用native函数直接在操作系统上分配堆外内存,然后使用DirectoryByteBuffer对象作为这块内存的引用对内存进行操作

```
Java进程可以通过堆外内存基数避免在Java堆和Native堆中来回复制数据带来的资源占用和性能消耗,因此堆外内存在高并发应用场景下被广泛应用(Netty,Flink,HBase,Hadoop都有使用堆外内存) 
```



## JVM 的运行时内存

JVM运行时内存也叫做JVM堆,从GC的角度分为 新生代,老年代和永久代.新生代默认占1/3空间,老年代默认占2/3空间,永久代只占用很少的堆空间.

新生代又分为 Eden区(8/10),ServivorFrom(1/10)和ServivorTo(1/10)空间

* Eden: Java新创建的对象会首先被存放到Eden区.如果新创建的对象属于大对象,直接分配到老年代.在Eden区内存空间不足的时候会触发MinortGC,对新生代进行一次垃圾回收.

```
大对象的定义根据具体的jvm版本,堆大小和垃圾回收策略有关,可以通过XX:PretenureSizeThreshold设置其大小.一般是2KB~128KB
```

* ServivorTo:保留上一次MinorGC时的幸存者
* ServivorFrom:将上一次MinorGC时的幸存者作为这一次MinorGC的被扫描者.

新生代的GC过程叫做Minor GC.采用复制算法实现.

* 把eden区和servivorFrom区中存活对象复制到servivorTo区.如果某对象的年龄到达老年代标准,则将其复制到老年代,同时把这些对象的年龄加1,如果servivorTo区内存不够,则也直接将其复制到老年代,如果对象属于大对象,也直接将其复制到老年代

```
对象晋升老年代的标准由 XX:MaxTenuringThreshold设置,默认是15
```

* 清空eden和servivorFrom区域的对象
* 将servivorTo区和servivorFrom区对换,原来的servivorTo区成为下一次GC时的ServivorFrom区

老年代主要存放有长生命周期的对象和大对象.老年代的GC过程叫做Major GC.MajorGC使用标记清除算法,该算法首先会扫描所有对象并标记存活对象,然后回收未被标记的对象,并释放内存空间.

```
在进行majorGC前,jvm会先进行一次Minor GC,如果MinorGC过后仍然出现老年代空间不足或者无法找到足够大的连续空间分配给新创建的大对象时,会触发Major GC进行垃圾回收.
Major会扫描所有老年代对象再回收,所以MajorGC的耗时比较长.同时MajorGC使用的标记清除算法容易产生内存碎片.在没有内存空间分配的时候,会报out of memory.
```

永久代指内存的永久保存区域,主要存放Class和meta(元数据)信息.Class在类加载时被放入永久代.GC不会在运行期间对永久代内存进行回收.所以永久代会随着Class的文件增加而增加,Class文件加载过多时会抛出Out of Memory.

```
在java8中,永久代被元数据区(元空间)取代.元数据区的作用和永久代类似,最大的区别是:
元数据区没有使用虚拟机的内存,而是直接使用操作系统的本地内存.因此,元空间的大小不受JVM内存限制,只和操作系统的内存有关.
在java8中,JVM将类的元数据放入本地内存(natvive memory)中,将常量池和类的静态变量放入java堆中.这样JVM能够加载多少元数据信息就不再由JVM的最大可用内存(MaxPermSize)空间决定,而是由操作系统的实际可用内存空间绝顶
```



## 垃圾回收与算法

### 如何确定垃圾

java采用引用计数器和可达性分析来确定对象是否可回收.

* 引用计数器方式容易产生循环依赖问题.
* 可达性分析 具体做法是首先定义一些GC Roots对象,然后以这些GC Roots对象作为起点向下搜索,如果在GC Roots和一个对象之间没有可达路径,则称该对象不可达.

```
不可达对象需要经过至少两次标记才能判定其是否可以被回收,如果在两次标记后该对象仍然是不可达的,则将被垃圾回收期回收.
```

### 常用垃圾回收算法

* 标记清除(Mark-Sweep)

分为标记和清除两个部分.在标记阶段标记所有需要回收的对象,在清除阶段清除可回收的对象并释放其所占的内存空间.

缺点:会引起内存碎片化问题,会引起大对象无法获得连续可用空间的问题

* 复制算法(Copying)

为了解决标记清除算法内存碎片化问题而设计的.

复制算法的内存清理效率高而易于实现,但是由于同一时刻只有一个内存区域可用,即可用的内存被压缩到原来的一半.因此存在大量的内存浪费.如果系统中有大量长时间存活对象时,在两个内存区域之间复制会影响系统效率.因此该算法只在对象"朝生夕死"状态下效率最高.

* 标记整理(Mark-Compact)

标记整理算法结合了标记清除算法和赋值算法的优点,其标记节点和标记清除算法节点相同,在标记完成后将存活对象移动到内存的另一端,然后清除该端对象并释放内存.

* 分代收集(Generational Collecting)

针对不同的对象类型,JVM采用了不同的垃圾回收算法,该算法被称为分代收集算法.

大部分JVM在新生代采用了复制算法;在老年代采用标记清除算法.

## Java中的4种引用类型

java对象的操作是通过该对象的引用(Reference)实现的

* 强引用: 有强引用的对象一定为可达性状态,所以不会被垃圾回收机制回收.因此,强引用是导致内存泄漏(Memory Link)的主要原因

* 软引用:通过SoftReference类实现,在系统内存空间不足时该对象将被回收;

* 弱引用:通过WeakReference类实现,如果对象只有弱引用,则在垃圾回收过程中一定会被回收;

* 虚引用:虚引用通过PhantomReference类实现,虚引用和引用队列联合使用,主要用于跟踪对象的垃圾回收状态.

## 分代收集算法和分区收集算法

### 分代收集算法

* 新生代 与复制算法
* 老年代与标记整理算法

### 分区收集算法

分区算法将整个堆空间划分为连续的大小不同的区域,对每个小区域都单独进行内存使用和垃圾回收,这样做的好处是可以根据每个小区域内存的大小灵活使用和释放内存.

```
分区收集算法可以根据系统可接受的停顿时间,每次都快速回收若干个小区域的内存 ,以缩短垃圾回收的停顿时间,最后以多次并行累加的方式逐步完成整个内存区域的垃圾回收.
```

## 垃圾收集器

### 针对新生代提供的垃圾收集器

* Serial 单线程,复制算法

基于复制算法实现,是一个单线程收集器.在它进行垃圾收集时,必须单暂停其他所有工作线程,知道垃圾收集结束.

Serial 是Java虚拟机运行在Client模式下新生代的默认垃圾收集器



* ParNew 多线程,复制算法

ParNew是Serial的多线程实现;在垃圾收集过程中会暂停其他所有工作线程,是Java虚拟机运行在Server模式下新生代的默认垃圾收集器

```
ParNew垃圾收集器默认开启与CPU同等数量的线程进行垃圾回收.在Java启动时可以通过 -XX:ParallelGCThreads参数调节ParNew垃圾收集器的工作线程数.
```



* Parallel Scavenge 多线程,复制算法

为了提高新生代垃圾收集效率而设计的垃圾收集器,基于多线程复制算法实现,在系统吞吐量上有很大的优化.可以更高效的利用CPU尽快完成垃圾回收任务.

Parallel Scavenge 通过自适应调节策略提高系统吞吐量,提供三个参数用于调节,控制垃圾回收的停顿时间和吞吐量

XX:MaxGCPauseMillis 控制最大垃圾收集停顿时间

XX:GCTimeRatio 控制吞吐量大小

UseAdaptiveSizePolicy 控制自适应调节策略开启与否



### 针对老年代提供的垃圾收集器

* Serial Old: Serial垃圾收集器的老年代实现

单线程,标记整理算法.

Serial Old是JVM运行在Client模式下的老年代的默认垃圾收集器



* Parallel Old 多线程,标记整理算法

Parallel Old在设计上优先考虑系统吞吐量,其次考虑停顿时间等因素.如果系统对吞吐量的要求比较高,可以使用新生代  Parallel Scavenge  + 老年代 Parallel Old.



* CMS

主要目的是达到最短的垃圾回收停顿时间,基于线程的标记清理算法实现,以便在多线程并发环境下以最短的垃圾收集停顿时间提高系统的稳定性.

CMS的工作机制相对复杂,垃圾回收过程包含如下4个步骤

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清除

```
 CMS垃圾收集器在和用户线程一起工作时(并发标记和并发清除)不需要暂停用户线程,有效缩短了垃圾回收时系统的停顿时间,同时由于CMS垃圾收集器和用户线程一起工作,因此其并行和效率也有很大提升.
```



### 针对不同区域的G1分区收集算法

G1 (Garbage First)

G1相对于CMS有两个突出改进

* 基于标记整理算法,不产生内存碎片
* 可以精确的控制停顿时间,在不牺牲吞吐量的前提下实现短停顿垃圾回收;

## Java 网络编程模型

### 阻塞I/O 

阻塞I/O模型的工作流程为:在用户线程发出I/O请求后,内核会检查数据是否就绪,此时用户线程会一直堵塞等待内存数据就绪,在内存数据就绪后,内核将数据复制到用户线程,并返回I/O执行结果到用户线程,此时用户线程解除阻塞状态并开始处理数据.

```
典型的阻塞I/O模型的例子是
data = socket.read();
如果内核数据没有就绪,socket线程就会一直阻塞在read()中等待内核数据就绪.
```

### 非阻塞I/O

非阻塞I/O模型是指用户线程在发起一个I/O操作后,无需阻塞便可以马上得到内核的一个结果.

```
在非阻塞I/O模型中,用户线程需要不断的轮训内核数据是否就绪,在内存数据还未就绪时,用户线程可以处理其他任务,在内核数据就绪后可以立即获取数据并进行相应的操作.
典型的非阻塞I/O模型一般如下
while(true){
	data = socket.read();
	if(data == true){
		//获取并处理内核数据
		break;
	}else{
		//内核数据还未就绪,处理其他任务
	}
}
```

### 多路复用I/O模型

多路复用I/O模型是多线程并发编程用的较多的模型,Java NIO就是基于多路复用I/O模型实现的.在多路复用I/O模型中会有一个被称为Selector的线程不断轮询多个Socket状态,只有在Socket状态有读写事件时,才会通知用户线程进行I/O读写操作.

多路复用I/O模型在连接数众多且消息体不大的情况下有很大的优势.**经过优化后的16核32G服务器能承载约10万台设备连接**

非阻塞I/O是在每个用户线程中都进行Socket状态检查,而在多路复用I/O模型中是在系统内核中进行Socket状态检查的,这也是多路复用I/O模型比非阻塞I/O模型效率高的原因

```
多路复用I/O模型在事件响应体(消息体)很大时,selector线程就会成为性能瓶颈,导致后续的事件迟迟得不到处理,影响下一轮的事件轮训.在实际应用中,在多路复用方法体内一般不建议做复杂逻辑运算,只做数据的接收和转发,将具体业务操作转发给后面的业务线程处理.
```

### 信号驱动I/O模型

在用户发起一个I/O请求操作时,系统会为该请求对应的socket注册一个信号函数,然后用户线程可以继续执行其他业务逻辑,在内核数据就绪后,系统会发送一个信号到用户线程,用户线程接收到信号后,会在信号函数中调用的I/O读写操作完成实际的I/O请求操作.

### 异步I/O模型



## JVM 类加载机制

### 类加载器

* 启动类加载器  JAVA_HOME/lib 或 Xbootclasspath
* 扩展类加载器 JAVA_HOME/ext/lib 或者 使用 java.ext.dirs
* 应用程序类加载器 加载用户路径 classpath上的类库

### 双亲委派

保障类的唯一性和安全性



## Java基础

### 集合

* List
  * ArrayList
  * LinkedList
  * Vector
* Queue
  * ArrayBlockingQueue
  * LinkedBlockingQueue
  * PriorityBlockingQueue
  * DelayQueue
  * SychronousQueue
  * LinkedTransferQueue
  * LinkedBlockingDueue
* Set
  * HashSet
  * TreeSet
  * LinkedSet
* Map
  * HashMap
  * HashTable
  * TreeMap

### 异常分类以及处理

Throwable

​	Error

​	Exception

​		checked Exception SQLException IOException FileNotFound...

​		RuntimeException eg NullPointer ClassCast ArrayIndexOutBounds...

### 反射机制

Java反射创建对象的两种方式

1. 使用newInstance创建该Class对象的对应实例,需要Class对象有默认的无参构造函数
2. 先使用Class对象获取指定的constructor对象,再调用constructor对象的newInstance方法创建class对象.

### 注解

@Target

@Retention

@Documented

@Inherited

### 内部类

静态内部类

成员内部类

局部内部类

匿名内部类

### 泛型

泛型标记和泛型限定 E T K V N ?

* E Element 在集合中使用,表示集合中存放的元素
* T Type 表示Java类中的基本类和自定义类型
* K Key 表示键 比如Map中的Key
* V value 表示值
* N Number 数值类型
* ? 不确定的Java类型
* List<? extends T> 上限 表示类都是 T的子类
* List<? super T> 下限 表示类都是 T的父类

类型擦除



### 序列化

对象序列化保存的是对象的状态,即它的成员变量,所以类中的静态变量不会保存;

## Java 并发编程

### Java线程的创建方式

继承Thread类

实现Runnable接口

通过ExecutorService和Callable<Class>实现有返回值的线程;

基于线程池;

### 线程池工作原理

JVM先根据用户的参数创建一定数量的可运行的线程任务,并将其放入队列中,在线程创建后启动这些任务,如果线程数量超过最大线程数量,则超出数量的线程排队等候,在有任务执行完毕后,线程池调度器会发现有可用线程,进入再次从队里中取出任务并执行;

线程池的主要作用是线程服用,线程资源管理,控制操作系统的最大并发数;

Java线程池主要由以下4个核心组件组成

* 线程池管理器 用于创建并管理线程池
* 工作线程 线程池中执行具体任务的线程
* 任务接口 用于定义工作线程的调度和执行策略,只有线程实现了该接口,线程中的任务才能够被线程池调度
* 任务队列 存放待处理的任务

Java中的线程池是通过Executor框架实现的,在该框架中用到了Executor,Executors,ExecutorService,ThreadPoolExecutor,Callabe,Future,FuterTask这几个核心类.

线程池拒绝策略

* AbortPolicy 直接抛出异常,拒绝执行
* CallerRunsPolicy 如果被丢弃的线程任务未关闭,则执行该线程任务(由当前线程执行被丢弃的任务,会导致主线程阻塞);
* DiscardOldestPolicy 移除线程队列中最早的一个线程任务,并尝试提交当前任务
* DiscardPolicy 丢弃当前的线程任务而不做任何处理
* 自定义拒绝策略

### 常用线程池

* `newCachedThreadPool`

* `newFixedThreadPool`

* `newScheduledTheadPool`

* `newSingleThreadExecutor`

* `newSingleThreadScheduledExecutor`

* `newWorkStealingPool`

### 线程的生命周期

* `New` 新建状态

* `Runable` 就绪状态
* `Running` 运行态
* `Blocked` 阻塞状态

运行中的线程会主动或被动的放弃CPU使用权并暂停运行,此时该线程转为阻塞状态,直到再次进入可运行状态,才有机会竞争到CPU使用权并转为运行态.阻塞的状态分为三种

1. 等待阻塞 运行态线程调用o.wait方法,JM会把该线程放入等待队列(Waiting Queue)中,线程转为阻塞状态
2. 同步阻塞 在运行状态的线程尝试获取正在被其他线程占用的对象锁时,JVM会把该线程放入锁池(Lock Pool)中,此时线程转为阻塞状态
3. 其他阻塞 运行状态线程执行sleep(),join()或者发出IO请求时,JVM会把该线程转为阻塞状态,直到sleep超时,join()等待线程终止或超时,或者IO处理完毕,线程才重新弄转为可运行状态.

* Dead 死亡

1. 线程正常结束 run方法或者call方法执行完毕;
2. 线程异常退出 抛出Error 或者未捕获异常
3. 手动结束 调用线程对象的stop方法手动结束运行中的线程(该方式会瞬间释放线程占用的同步对象锁,导致锁混乱和死锁,不推荐使用)

### 线程的基本方法

* wait 在调用wait方法后会释放对象的锁,所以wait方法一般被用于同步方法或同步代码块中,线程会进入 WAITING 状态
* sleep sleep方法不会释放当前占有的锁,会导致线程进入 TIME-WAITING状态
* yield 线程让步 调永yield方法会使当前线程让出(释放)CPU执行时间片,与其他线程一起竞争CPU时间片.

### Java 中的锁



### 线程上下文切换



### Java 阻塞队列



### Java并发关键字



### 多线程共享数据



### ConcurrentHashMap并发



### Java 线程调度



### 进程调度算法



### CAS



### ABA问题



### AQS

## 数据结构



## 算法



## 网络与负载均衡



## 数据库与分布式事务



## 分布式缓存的原理和应用



## 设计模式

